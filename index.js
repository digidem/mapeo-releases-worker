// @ts-check
import { Router } from 'itty-router'
import yaml from 'js-yaml'
import path from 'path'

// Create a new router
const router = Router()

const s3bucket = 'downloads.mapeo.app'
const s3hostname = 's3.amazonaws.com'

/**
 * Use yaml files generated by build process to redirect to latest release/beta
 */
router.get('/desktop/*/(latest|beta)-(win|mac|linux)', handleYamlRequest)
router.get('/desktop-icca/*/(latest|beta)-(win|mac|linux)', handleYamlRequest)

/** @param {import('itty-router').Request} request */
async function handleYamlRequest(request) {
  const s3Url = new URL(request.url)
  s3Url.protocol = 'https:'
  s3Url.hostname = s3hostname
  // Electron Updater uses latest.yml for windows releases, not latest-win.yml
  s3Url.pathname = `/${s3bucket}/${s3Url.pathname.replace(/-win$/, '')}.yml`

  let response = await fetch(s3Url.toString())
  // Returning undefined here will pass through to the next handler
  if (response.status === 404) return
  // Logs a warning because s3 returns everything as application/octet-stream
  const infoString = await response.text()
  /** @type {any} */
  const info = yaml.load(infoString)
  if (!info || typeof info.path !== 'string') {
    return new Response('Not Found!', { status: 404 })
  }

  const redirectUrl = new URL(request.url)
  redirectUrl.pathname = path.dirname(redirectUrl.pathname) + '/' + info.path

  return Response.redirect(redirectUrl.toString(), 302)
}

/**
 * Don't proxy the S3 bucket listing URL which is what AWS returns for the root request
 */
router.get('/', (request) => {
  return new Response('Not Found!', { status: 404 })
})

/**
 * Proxy all other requests to the s3 bucket
 */
router.all('*', async (request) => {
  const url = new URL(request.url)
  url.hostname = s3hostname
  url.pathname = `/${s3bucket}${url.pathname}`
  url.protocol = 'https:'
  const response = await fetch(url.toString(), request)
  if (response.status !== 200) {
    return new Response('Not Found!', { status: 404 })
  }
  return response
})

/*
This snippet ties our worker to the router we defined above, all incoming requests
are passed to the router where your routes are called and the response is sent.
*/
addEventListener('fetch', (e) => {
  e.respondWith(router.handle(e.request).catch(onError))
})

/** @param {Error & { status?: number }} error */
function onError(error) {
  console.error(error)
  return new Response('Error: ' + error.message || 'Server Error', {
    status: error.status || 500,
  })
}
